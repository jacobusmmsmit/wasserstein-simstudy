require(Rcpp)
sourceCpp("network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
setwd("~/git/wasserstein-simstudy/src")
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
getwd()
setwd("~/git/wasserstein-simstudy")
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
n <- 1000 # Sample size
d <- 10   # Dimension
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
muhat
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out[i, j] = mean((muhat[i] - nuhat[j])^2);
}
}
return out;
}')
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])**^2)
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])**^2)
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out[i, j] = mean((muhat[i] - nuhat[j])**2);
}
}
return out;
}')
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out(i, j) = mean((muhat[i] - nuhat[j])**2);
}
}
return out;
}')
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
muhat
muhat[, 1]
muhat[, 2]
muhat[, 3]
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat)
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
nuhat <- matrix(rnorm(n * d), nrow = d)
costMatrix(muhat, nuhat)
# (This double loop is an atrocity. Please vectorize your code.)
# Just write this in C, like, it's faster, as is with indexing from 0 remember ;)
cost_mat <- matrix(NA, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])^2)
}
}
cost_mat
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat)
# (This double loop is an atrocity. Please vectorize your code.)
# Just write this in C, like, it's faster, as is with indexing from 0 remember ;)
cost_mat <- matrix(NA, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])^2)
}
}
cost_mat2 <- costMatrix(muhat, nuhat)
cost_mat == cost_mat2
all(cost_mat == cost_mat2)
sourceCpp("src/costMatrix.cpp")
cost_mat <- costMatrix(muhat, nuhat, 2)
cost_mat
costMatrix(muhat, nuhat, 3)
costMatrix(muhat, nuhat, 5)
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat, 5)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat
cost_mat <- costMatrix(muhat, nuhat, 2)
cost_mat
type(costMatrix)
typeof(costMatrix)
typeof(mean)
typeof(as.data.frame())
typeof(as.data.frame
)
sourceCpp("costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")#
cost_mat
cost_mat2 <- costmat
cost_mat2 <- cost_mat
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat2 == cost_mat
cost_mat
sourceCpp("src/costMatrix.cpp")#
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
sourceCpp("src/costMatrix.cpp")#
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
sourceCpp("src/costMatrix.cpp")
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
install.packages("JuliaCall")
julia <- julia_setup()
library(JuliaCall)
julia <- julia_setup()
julia <- julia_setup()
julia <- julia_setup()
require(JuliaCall)
julia <- julia_setup()
julia_eval("sqrt(2)")
julia_eval("sqrt(2)")
julia_eval("sqrt(2)")
julia_source("costMatrixjl.jl")
costMatrixjl(c(1,2,3),c(1,2,3))
julia_exists("costMatrixjl")
julia_call("costMatrixjl", c(1,2,3),c(1,2,3))
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", c(1,2,3),c(1,2,3))
julia_call("costMatrixjl", c(1,2,3),c(1,2,3), 2, 2)
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", c(1,2,3),c(1,2,3), 2, 2)
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", c(1,2,3),c(1,2,3), 2, 2)
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", c(1,2,3),c(1,2,3), 2, 2)
julia_call("costMatrixjl", muhat,nuhat, 2, 2)
require(JuliaCall)
julia <- julia_setup()
require(Rcpp)
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
sourceCpp("src/costMatrix.cpp")
julia_source("costMatrixjl.jl")
n <- 1000 # Sample size
d <- 10   # Dimension
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
nuhat <- matrix(rnorm(n * d), nrow = d)
cost_mat <- costMatrix(muhat, nuhat, 2, 2) # L-2 metric, wasserstein 2 norm
julia_call("costMatrixjl", muhat,nuhat, 2, 2)
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", muhat,nuhat, 2, 2)
julia_source("costMatrixjl.jl")
julia_call("costMatrixjl", muhat,nuhat, 2, 2)
costMatrix(muhat, nuhat, 2, 2) # L-2 metric, wasserstein 2 norm
julia_call("costMatrixjl", muhat,nuhat, 2, 2)
cm1 <- costMatrix(muhat, nuhat, 2, 2) # L-2 metric, wasserstein 2 norm
cm2 <- julia_call("costMatrixjl", muhat,nuhat, 2, 2)
all(cm1 == cm2)
sum(cm1)
sum(cm2)
