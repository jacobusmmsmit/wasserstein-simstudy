require(Rcpp)
sourceCpp("network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
setwd("~/git/wasserstein-simstudy/src")
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
getwd()
setwd("~/git/wasserstein-simstudy")
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
n <- 1000 # Sample size
d <- 10   # Dimension
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
muhat
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out[i, j] = mean((muhat[i] - nuhat[j])^2);
}
}
return out;
}')
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])**^2)
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])**^2)
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out[i, j] = mean((muhat[i] - nuhat[j])**2);
}
}
return out;
}')
cppFunction('NumericMatrix costMatrix(NumericVector muhat, NumericVector nuhat) {
int muhatSize = muhat.size(), nuhatSize = nuhat.size();
NumericMatrix out(muhatSize, nuhatSize);
for (int i = 0; i < muhatSize; i++) {
for (int j = 0; j < nuhatSize; j++) {
out(i, j) = mean((muhat[i] - nuhat[j])**2);
}
}
return out;
}')
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
muhat
muhat[, 1]
muhat[, 2]
muhat[, 3]
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat)
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
nuhat <- matrix(rnorm(n * d), nrow = d)
costMatrix(muhat, nuhat)
# (This double loop is an atrocity. Please vectorize your code.)
# Just write this in C, like, it's faster, as is with indexing from 0 remember ;)
cost_mat <- matrix(NA, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])^2)
}
}
cost_mat
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat)
# (This double loop is an atrocity. Please vectorize your code.)
# Just write this in C, like, it's faster, as is with indexing from 0 remember ;)
cost_mat <- matrix(NA, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
cost_mat[i, j] <- mean((muhat[, i] - nuhat[, j])^2)
}
}
cost_mat2 <- costMatrix(muhat, nuhat)
cost_mat == cost_mat2
all(cost_mat == cost_mat2)
sourceCpp("src/costMatrix.cpp")
cost_mat <- costMatrix(muhat, nuhat, 2)
cost_mat
costMatrix(muhat, nuhat, 3)
costMatrix(muhat, nuhat, 5)
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
costMatrix(muhat, nuhat, 5)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat <- costMatrix(muhat, nuhat, 3)
cost_mat
cost_mat <- costMatrix(muhat, nuhat, 2)
cost_mat
type(costMatrix)
typeof(costMatrix)
typeof(mean)
typeof(as.data.frame())
typeof(as.data.frame
)
sourceCpp("costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")
sourceCpp("src/costMatrix.cpp")#
cost_mat
cost_mat2 <- costmat
cost_mat2 <- cost_mat
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat2 == cost_mat
cost_mat
sourceCpp("src/costMatrix.cpp")#
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
sourceCpp("src/costMatrix.cpp")#
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
sourceCpp("src/costMatrix.cpp")
cost_mat <- costMatrix(muhat, nuhat, 2, 2)
cost_mat
install.packages("JuliaCall")
julia <- julia_setup()
library(JuliaCall)
julia <- julia_setup()
julia <- julia_setup()
julia <- julia_setup()
require(JuliaCall)
julia <- julia_setup()
# require(JuliaCall)
# julia <- julia_setup()
require(Rcpp)
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
sourceCpp("src/costMatrix.cpp")
# Investigate:
# Easy ("Good"): Look at variance of Wp^p (wasserstein p distance to the p) and Wp when ?? = ?? as N increases
# Loop, store distance, compute estimator of sample variance (1/n ? sum((xi - x??)^2))
# var(c(10 9 8 7 6 5 4 3 2 1))
# pattern: want plot variance against N, definintely for Wp^p goes down faster than 1/n, interesting: find out the exponent.
# it's n^-c c> 1 but how big is this and how does it depend on dimension
# How to see what size of c is:
# Imagine I know a-priori it's logvar = logc * c log(n)
# log log plot of variance against sample size then slope = c < -1
# Then take p^th root then calculate variance and then loglog plot of variance against sample size
# Pattern should be the same for whatever mertic and exponent p > 1
# Which exact metic to take and which exponent tot ake is pretty wide
# Start with euclidean norm exponent 2, then integer exponents
# Sample size up to 10,000
# Replicates: A couple
# Wasserstein takes a metric d and then (integral( d(x - y) ^p)^1/p
# d <- function(x, y, q = 2) {(sum(x - y)^q)^(1/q)} # = Lq-norm which then induces a metric but yeah
# preliminary investigation: CLT papers on Optimal transport ?? if I would like (only, otherwise do not, i repeat do not unless you would like)
# Came out february, good papers -> you must enjoy them. contains refernece to previous work which is pretty good
# https://arxiv.org/pdf/2102.06379.pdf
# require(JuliaCall)
# julia <- julia_setup()
require(Rcpp)
sourceCpp("src/network_simplex_fast.cpp") # Compile and load the solver. The header files are also necessary.
sourceCpp("src/costMatrix.cpp")
# julia_source("src/costMatrix.jl")
n <- 1000 # Sample size
d <- 10   # Dimension
# 1.) Generate samples (they don't have to be normal)
muhat <- matrix(rnorm(n * d), nrow = d) # n samples from a standard normal, stored as one sample per column
nuhat <- matrix(rnorm(n * d), nrow = d)
# 2.) Compute the cost matrix
# If x_i is the i-th sample from mu, its entries are c_{ij} = 1/n * ||x_i - y_i||_2^2.
# In general, you'll do c_{ij} = 1/n * d(x_i, y_i)^p.
cost_mat <- costMatrix(muhat, nuhat, 2, 2) # L-2 metric, wasserstein 2 norm
cm <- costMatrix(muhat, nuhat, 2, 2) # L-2 metric, wasserstein 2 norm
# cm2 <- julia_call("costMatrixjl", muhat,nuhat, 2, 2)
# remake the cost matrix
# 3.) Compute the distance from the cost matrix
w2_empirical <- sqrt(SolveAssignmentNetworkflow(cost_mat))
w2_empirical
muhat
for (i in 1:10){
print(i)
}
print(muhat[1:i, 1:i])
for (i in 1:10){
print(muhat[1:i, 1:i])
}
w2_emp <- []
w2_emp <- c()
for (i in 1:10){
mh <- muhat[1:i, 1:i]
nh <- nuhat[1:i, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i] <- sqrt(SolveAssignmentNetworkflow(cm))
}
muhat[1:i, 1:i]
for (i in 2:10){
mh <- muhat[1:i, 1:i]
nh <- nuhat[1:i, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp
w2_emp <- c()
for (i in 2:10){
mh <- muhat[1:i, 1:i]
nh <- nuhat[1:i, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp
w2_emp <- c()
for (i in 2:100){
mh <- muhat[1:i, 1:i]
nh <- nuhat[1:i, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
muhat
size(muhat)
nrows(muhat)
dim(muhat)
w2_emp <- c()
for (i in 2:100){
mh <- muhat[10, 1:i]
nh <- nuhat[10, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
for (i in 2:100){
mh <- muhat[10, 1:i]
nh <- nuhat[10, 1:i]
print(i)
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
for (i in 2:100){
mh <- muhat[10, 1:i]
nh <- nuhat[10, 1:i]
print(mh)
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
for (i in 2:100){
mh <- muhat[1:10, 1:i]
nh <- nuhat[1:10, 1:i]
print(mh)
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
for (i in 2:100){
mh <- muhat[1:10, 1:i]
nh <- nuhat[1:10, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp
for (i in 2:1000){
mh <- muhat[1:10, 1:i]
nh <- nuhat[1:10, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp
w2_emp_vars <- rep(0, 999)
w2_emp
w2_emp_vars
for (i in 2:1000){
w2_emp_vars <- var(w2_emp[1:i])
}
w2_emp_vars
for (i in 2:1000){
w2_emp_vars <- var(w2_emp[1:i])
}
w2_emp_vars
w2_emp_vars <- rep(0, 999)
for (i in 2:1000){
w2_emp_vars[i] <- var(w2_emp[1:i])
}
w2_emp_vars
var(w2_emp[1:i])
var(w2_emp[1:i])
i
var(w2_emp[1:1000])
w2_emp
w2_emp[1]
w2_emp[1000]
w2_emp[1001]
w2_emp_vars <- rep(0, 999)
for (i in 2:999){
w2_emp_vars[i] <- var(w2_emp[1:i])
}
w2_emp_vars
plot(2:1000, w2_emp_vars)
plot(2:1000, w2_emp_vars, log = "xy")
plot(log(2:1000), log(w2_emp_vars))
w2_emp_vars
w2_emp
var(w2_emp[900:1000])
var(w2_emp[900:1000])
w2_emp[900:1000]
w2_emp[900:999]
var(w2_emp[900:999])
var(w2_emp[1:999])
var(w2_emp[1:998])
var(w2_emp[1:999])
w2_emp <- c()
for (i in 500:1000){
mh <- muhat[1:10, 1:i]
nh <- nuhat[1:10, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp_vars <- rep(0, 999)
for (i in 2:999){
w2_emp_vars[i] <- var(w2_emp[1:i])
}
w2_emp_vars
plot(2:1000, w2_emp_vars, log = "xy")
w2_emp
for (i in 500:1000){
mh <- muhat[1:10, 500:i]
nh <- nuhat[1:10, 500:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
for (i in 501:1000){
mh <- muhat[1:10, 500:i]
nh <- nuhat[1:10, 500:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp_vars <- rep(0, 499)
for (i in 2:499){
w2_emp_vars[i] <- var(w2_emp[1:i])
}
w2_emp_vars
w2_emp
w2_emp <- c()
for (i in 2:1000){
mh <- muhat[1:10, 1:i]
nh <- nuhat[1:10, 1:i]
cm <- costMatrix(mh, nh, 2, 2)
w2_emp[i-1] <- sqrt(SolveAssignmentNetworkflow(cm))
}
w2_emp_vars <- rep(0, 999)
for (i in 2:999){
w2_emp_vars[i] <- var(w2_emp[1:i])
}
w2_emp_vars
plot(2:1000, w2_emp_vars, log = "xy")
plot(log(2:1000), log(w2_emp_vars))
s
sadfasd
))
